1、mixin合并规则
    1.1、如果data返回值对象的属性发生了冲突，会保留组件自身的数据
    1.2、生命周期钩子函数会被合并到数组中，都会被调用
    1.3、methods/computed/components等都会被合并为一个对象，如果重名，会保留组件自身的键值对

2、全局混入
    app.mixin({
        data() {

        },
        methods: {
            
        }
    })

3、reactive判断的API
    1、isProxy
        检查对象是否是由 reactive 或 readonly创建的proxy
    2、isReactive
        检查对象是都是由 reactive 创建的响应式代理
        如果该代理是readonly创建的，但是包裹了由 reactive 创建的另一个代理，也会返回true
    3、isReadonly
        检查对象是否是由 readonly 创建的只读代理
    4、toRaw
        返回reactive 或 readonly 代理的原始对象
    5、shallowReactive
        创建一个响应式代理，它跟踪其自身property的响应性，但不执行嵌套对象的深层响应式转换
    6、shallowReadonly
        创建一个proxy，使其自身的property为只读，但不执行嵌套对象的深度只读转换

4、ref其他的API
    1、unref: 获取一个ref引用中的value
        如果参数是一个ref，返回内部值，否则返回参数本身
        val = isRef(val) ? val.value : val
    2、isRef
        判断值是否是一个ref对象
    3、shallowRef
        创建一个浅层的ref对象
    4、triggerRef
        手动触发 和 shallowRef 相关的副作用
    5、customRef
        创建一个自定义的ref,并对其依赖项跟踪或更新触发进行显示控制
        1、他需要一个工厂函数，该函数接收 track 和 trigger 函数作为参数
        2、并且应该返回一个带有get和set的对象